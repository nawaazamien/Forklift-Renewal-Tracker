# ðŸ’­ Reflection

## 1. Challenges Faced in Designing the Domain Model and Class Diagram

Designing the domain model and class diagram for the **Forklift License Renewal Tracker** project presented several challenges. One of the main difficulties was achieving the right level of abstraction. For example, deciding whether to treat `License` as a separate entity or as an attribute of `ForkliftOperator` required careful consideration. Ultimately, I chose to make `License` a separate entity because it has its own attributes (e.g., `expiryDate`, `status`) and methods (e.g., `validateLicense()`, `renewLicense()`), which justified its independence.

Defining relationships between entities was another challenge. For instance, the relationship between `OperationsManager` and `ComplianceReport` required a decision on whether it should be an aggregation or a composition. Since a compliance report cannot exist without being generated by an operations manager, I opted for composition. Similarly, determining the multiplicity of relationships, such as how many `ForkliftOperators` an `OperationsManager` can manage, required aligning with the systemâ€™s requirements and use cases.

Method definitions also posed challenges, especially for entities like `ITAdministrator` and `System`. These entities are more technical and less user-facing, so defining meaningful methods like `performSecurityAudit()` and `deploy()` required thinking about how these actions would be implemented in the real system. Ensuring that each method aligned with the responsibilities of its class was critical to maintaining a clean and logical design.

---

## 2. Alignment with Previous Assignments

The class diagram aligns closely with the requirements, use cases, and state diagrams from previous assignments. For example:
- The **ForkliftOperator** class directly supports use cases like "Register License" and "Update License." Its methods (`registerLicense()`, `updateLicense()`) reflect these functionalities.
- The **Reminder** class aligns with the requirement to send notifications 30 days and 7 days before a license expires. This ensures that the system meets its core functionality of keeping operators compliant.
- The **ComplianceReport** class supports the use case for operations managers to view compliance data, as outlined in the state diagrams and requirements.
- Relationships like `OperationsManager` managing multiple `ForkliftOperators` and generating `ComplianceReports` were derived from the stakeholder needs and system requirements.

By maintaining traceability to earlier assignments, the class diagram ensures that the design is consistent with the projectâ€™s goals and user expectations.

---

## 3. Trade-offs Made

Several trade-offs were made during the design process to balance simplicity and functionality:
1. **Simplifying Inheritance**: While inheritance could have been used to create a hierarchy for roles like `ForkliftOperator` and `OperationsManager`, I chose to keep them as separate classes. This avoided unnecessary complexity and made the design easier to understand and implement.
2. **Composition vs. Aggregation**: For relationships like `OperationsManager` generating `ComplianceReports`, I opted for composition because reports are tightly coupled with the manager who generates them. However, for `OperationsManager` managing `ForkliftOperators`, I used aggregation to reflect a looser relationship.
3. **Method Scope**: Some methods, like `validateLicense()` in the `License` class, were simplified to focus on core functionality. More complex validations (e.g., checking against external databases) were left out to keep the design manageable.

These trade-offs ensured that the design remained practical while still meeting the systemâ€™s requirements.

---

## 4. Lessons Learned About Object-Oriented Design

This assignment reinforced several key lessons about object-oriented design:
1. **Abstraction is Key**: Identifying the right level of abstraction for entities and their attributes is critical. Overcomplicating the design can make it harder to implement, while oversimplifying can lead to missing functionality.
2. **Relationships Matter**: Defining clear relationships between entities ensures that the systemâ€™s structure reflects real-world interactions. Multiplicity and relationship types (e.g., association, composition) play a significant role in creating a logical design.
3. **Traceability is Essential**: Aligning the class diagram with requirements, use cases, and state diagrams ensures that the design stays consistent with the projectâ€™s goals. This traceability also makes it easier to justify design decisions.
4. **Trade-offs are Necessary**: Balancing simplicity and functionality is a constant challenge in design. Making thoughtful trade-offs helps create a design that is both practical and effective.
5. **Iterative Design is Valuable**: The process of refining the domain model and class diagram highlighted the importance of iteration. Revisiting and improving the design based on feedback and new insights ensures a better final product.

Overall, this assignment deepened my understanding of object-oriented design principles and their application in real-world systems. It also emphasized the importance of aligning technical design with user needs and project requirements.